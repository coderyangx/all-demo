<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>react</title>
</head>

<body>

</body>
<script>
  function MyApp({ cnt, onClick }) {
    return (
      <button onClick={onClick}>
        {cnt}
      </button>
    )
  }

  // reducer 函数就是你放置状态逻辑的地方。它接受两个参数，
  // 分别为当前 state 和 action 对象，并且返回的是更新后的 state：
  function tasksReducer(task, action) {
    // 给 React 返回更新后的状态
    switch (task.type) {
      case 'changed': {
        return tasks.map((t) => {
          if (t.id === action.task.id) {
            return action.task;
          } else {
            return t;
          }
        });
      }
    }
  }
  const initialTasks = [
    { id: 0, text: '参观卡夫卡博物馆', done: true },
    { id: 1, text: '看木偶戏', done: false },
  ];
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId,
    });
  }

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]);
// 纯函数：组件作为公式


// mobx-react
import {inject, observer} from 'mobx-react'
@inject('store')
@observer
const App: React.FC<IProps> = (props) => { }

// APP组件能接收的props泛型
const App1 = (props: IProps) => { }

// umi:约定路由 嵌套路由：props.children



import {observable, autorun} from 'mobx'

var observNum = observable.box(10)
var obj = observable({
  name: 'ww',
  age: 23
})
// 第一次执行，每次更新也执行
autorun(() => {
  console.log(observNum.get());
  console.log(obj.name);
})






</script>

</html>